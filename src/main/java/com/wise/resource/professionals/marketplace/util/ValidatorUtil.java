package com.wise.resource.professionals.marketplace.util;

import com.wise.resource.professionals.marketplace.to.InvalidFieldsAndDataTO;
import javafx.scene.control.Control;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.validation.ConstraintViolation;
import java.util.Collection;
import java.util.HashMap;
import java.util.Set;

/**
 * Helper methods surrounding validation
 */
@Component
public class ValidatorUtil {

    @Autowired
    private ComponentUtil componentUtil;

    /**
     * Gets a {@link String} array containing the fields that caused each {@link ConstraintViolation}
     *
     * @param constraintViolations a set of {@link ConstraintViolation}, generated by Javax
     * @return a {@link String} array of the offending fields
     */
    public <T> String[] getFieldsFromConstraintViolations(Set<ConstraintViolation<T>> constraintViolations) {
        String[] fields = new String[constraintViolations.size()];

        int i = -1;
        for (ConstraintViolation<T> constraintViolation : constraintViolations) {
            i++;

            fields[i] = getFieldFromConstraintViolation(constraintViolation);
        }

        return fields;
    }

    /**
     * Gets a fields that caused the {@link ConstraintViolation}
     *
     * @param constraintViolation a {@link ConstraintViolation}, generated by Javax
     * @return the offending fields
     */
    public <T> String getFieldFromConstraintViolation(ConstraintViolation<T> constraintViolation) {
        return constraintViolation.getPropertyPath().toString();
    }

    /**
     * Marks a control as negative; setting the given {@code negativeStyleClass}
     *
     * @param control            the control to be impacted
     * @param negativeStyleClass the style class to have set
     */
    public void markControlNegative(Control control, String negativeStyleClass) {
        componentUtil.safeAddStyleClass(control, negativeStyleClass);
    }

    /**
     * Marks a control as positive; removing the given {@code negativeStyleClass}
     *
     * @param control            the control to be impacted
     * @param negativeStyleClass the style class to have removed
     */
    public void markControlPositive(Control control, String negativeStyleClass) {
        control.getStyleClass().remove(negativeStyleClass);
    }

    /**
     * Uses a mapping of fields to controls, a list of offending fields, and a negative style class to determine which
     * fields should be marked positive or negative.
     * <p>
     * Marks all violating fields from {@code fields} as negative. Any fields not marked as negative that exist only in
     * {@code fieldToControl} are marked as positive.
     *
     * @param fields             the offending fields
     * @param fieldToControl     a mapping of a field to a given JavaFX control
     * @param negativeStyleClass the negative style class
     */
    public void markControlAgainstValidatedTO(
            String[] fields,
            HashMap<String, Control> fieldToControl,
            String negativeStyleClass) {

        Collection<Control> validControls = fieldToControl.values();

        for (String field : fields) {
            if (fieldToControl.containsKey(field)) {
                Control control = fieldToControl.get(field);

                markControlNegative(control, negativeStyleClass);
                validControls.remove(control);
            }
        }

        for (Control control : validControls) {
            markControlPositive(control, negativeStyleClass);
        }
    }


    /**
     * Creates an {@link InvalidFieldsAndDataTO} object and sets both {@link InvalidFieldsAndDataTO#invalidFields} and
     * {@link InvalidFieldsAndDataTO#data} based on the given violations.
     * <p>
     * If {@code violations} are empty then, the {@link InvalidFieldsAndDataTO#invalidFields} are set as the given
     * {@code violations} and the {@link InvalidFieldsAndDataTO#data} is set to null.
     * <p>
     * If {@code violations} are not empty, then {@link InvalidFieldsAndDataTO#invalidFields} are set to an empty String
     * array and the {@link InvalidFieldsAndDataTO#data} is set to the given {@code data}.
     *
     * @param violations a set of violations from Javax
     * @param data       the data to be set if no violations are present
     * @return the generated {@link InvalidFieldsAndDataTO} object
     */
    public <T> InvalidFieldsAndDataTO<T> populateInvalidFieldsAndDataTO(Set<ConstraintViolation<T>> violations, T data) {
        InvalidFieldsAndDataTO<T> output = new InvalidFieldsAndDataTO<>();

        if (violations.size() > 0) {
            output.setInvalidFields(getFieldsFromConstraintViolations(violations));
            output.setData(null);
        } else {
            output.setInvalidFields(new String[]{});
            output.setData(data);
        }

        return output;
    }
}
